# Work thus far

So far, our project has consisted of modelling the two machines which we aim to use in our proof. Since we aim to prove that the game Magic: The Gathering is Turing equivalent, we first modeled the Universal Turing Machine with 2 states and 18 symbols, ofter referred to as Rogozhin's UTM(2, 18) as he discovered that it was universally Turing complete in 1996. 

## The UTM 

Our model for this follows in the footsteps of J Strother Moore's 4-tuple Rogers Turing machine, used in his proof that the M1 language is Turing complete. We have some key differences, notably that instead of 4 tuple instructions, we must describe our instructions with 5 symbols, as the Rogozhin UTM is able to both write a symbol and move to the left/right, rather than just one of these operations at a time. We therefore need to perform both of these operations when we produce a new tape, which is also modeled based on the tape Moore used. 

Our UTM interpreter, `utmi`, performs `n` operations on a tape with the Turing machine specified by the rules in `*utm-2-18*`. It returns `nil` if the tape has run for `n` steps without terminating, or if the tape has encountered a `HALT` symbol. On a Rogozhin UTM, this is equivalent to the head moving past the leftmost symbol written on the tape, `'c<1`. However, for now, we choose to model this with the `HALT` symbol. 

## MTG 

We have additionally modeled the game Magic: The Gathering in ACL2, in a very limited fashion. We've implemented the *Creature* card type type, which are used in *Magic: The Gathering is Turing Complete*[^1] to model the symbols of a UTM(2, 18). Additionally, we retain specific information from these creatures. The *name* of a creature represents one of the 18 symbols in the Rogozhin UTM alphabet, using creatures with names that begin with different letters to distinguish them easily. The *power and toughness* of a creature determines how far offset it is from the head of the Turing machine, with 2 being the position of the head. The *color* of a creature determines whether the symbol is offset to the left or the right of the head, as power and toughness cannot dip below 0 by the rules of the game, meaning that expressing negative offsets would not be possible by the rules of the game.

In addition to *creatures*, we have modeled different cards in the game which allow it to embed the UTM(2, 18). We model the card [Rotlung Reanimator](https://scryfall.com/card/ons/164/rotlung-reanimator) and [Xathrid Necromancer](https://scryfall.com/card/c20/141/xathrid-necromancer), which each create a 2/2 black Zombie token, either tapped or untapped. For the sake of the Turing machine, these represent a *production function*; specifically, a Rotlung represents a production function where the state remains the same, while a Xathrid represents a production function where the state changes. Additional cards are used to change the text of these cards' rules, such that the creature tokens produced can be of any creature type or color specified. This allows the cards to produce white or green tokens with creature types that correspond to the Rogozhin alphabet, enabling them to serve as production functions. Additionally, four more cards are used which we model as functions operating on the machine. [Infest]() allows for the removal of the head of the tape, as it reduces all creatures' power and toughness by 2 until the end of the in game turn, which will reduce the head's toughness to 0, killing it (removing the current symbol there) and triggering a Rotlung Reanimator or Xathrid Necromancer to produce a new creature (the new head). [Cleansing Beam](https://scryfall.com/card/cma/78/cleansing-beam) combined with [Vigor](https://scryfall.com/card/bbd/215/vigor) gives all creatures of a certain color 2 additional power and toughness, while [Soul Snuffers](https://scryfall.com/card/td2/60/soul-snuffers) removes 1 power and toughness from all creatures. This allows the tape to move left/right, as we **increase** the offset from the head in one direction, and **decrease** the offset in the other. This also establishes a new head, as some other creature which had 3 power and toughness in either direction will now have 2 power and toughness, so it is at the head spot. All of these cards are modeled through functions which operate on the "tape", or list of creature tokens which represent symbols on a Turing machine, so that we can produce a new tape and have a function `mtgi` which updates our playing board accordingly.

## Unimplemented MTG

We made a conscious decision **not** to implement certain parts of MTG which the proof uses into ACL2 at the current time. Our reasoning for this is twofold: first, this allows us to build up our model, rather than starting with a more abstract model of MTG and needing to reduce it down to a UTM. This means we can be sure a given reduction works, before implementing more MTG features into our code. Second, we need to be sure that we are able to deliver a product. Implementing the full system for MTG might be outside the scope of what we are capable of, so we want to ensure we can deliver a final product by targeting this reduced version of MTG ***first***, and building up from there if we can successfully prove that.

# Current concerns, TODO

Our next steps are as follows:
- Reduce the MTG machine to a simpler machine, which eliminates ordering by toughness/color and orders based on that
- Prove theorems A and B for the two machines
- If time permits, implement tapped creatures and phasing into the MTG model
- reduce this model to our initial MTG model

These first two steps are pivotal to completing our project, and we have begun work on the first one, but don't have any code which is truly deliverable at this time, as we're still working out the logistics of this proof. This step only requires mapping the unordered list of creatures to an ordered list of creatures, with all information about their position removed. We first write a function which processes a list and orderes the creatures accordingly. We then develop a proof that the output of a machine which processes these creatures is equivalent to mapping the first pass of `mtgi` to output on the same tape/program. The second proof we believe is easier than the existing Moore proof, as that proof needed to find an existing natural that caused both programs to terminate with the same tapes, as the M1 machine ran much slower than the Rogers TM, while the UTM/MTG machine are 1-to-1 in terms of steps: the UTM is directly embedded in MTG. Therefore, we do not need to develop the clock lemmas, or find-j/find-k functions which Moore does. We only need to prove theorems A and B, which require some intermediate lemmas, in particular that the MTG machine stays halted when further instructions are run.

The next two steps we began work on, but decided to set aside to focus on getting results from the proof first. These steps would require modelling the tapped state for creatures, as well as *phasing* for the production functions, which is how MTG handles state changes (only one set of production functions is active at one time). This would require adding a boolean to the representation of creatures and production functions, and slowing down the speed at which the MTG TM operates to accurately reflect turns in MTG. This would require developing the clocks similar to what Moore did, although this too would be simpler-- we know that any instruction with a state change takes 3 turns, while any instruction without takes 4 turns. We will attempt to implement this following the success of the initial proof. If we aren't able to implement this step, we still have a working proof of a reduced representation for Magic: The Gathering.

# Overall status


[^1]: https://arxiv.org/pdf/1904.09828.pdf
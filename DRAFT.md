# Work thus far

We aim to verify the proof of Magic the Gathering's (henceforth MTG) Turing completeness using ACL2. As such, we've been working on implementing robust models of Rogozhin's UTM(2,18) and the Magic the Gathering Turing machine suitable for proof work in ACL2.

## The UTM 

Our implementation of UTM(2,18) is similar to that of J Strother Moore's 4-tuple Rogers Turing machine, used in his proof that the M1 language is Turing complete, with some key differences. Notably, instead of 4-tuple instructions, we are forced to use 5-tuple instructions: UTM(2,18) is able to both write a symbol and move the head in a single instruction, rather than just one of these operations at a time. We therefore need to perform both of these operations when we produce a new tape, which is also modeled based on the tape Moore used. 

Our UTM interpreter, `utmi`, performs `n` operations on a tape with the Turing machine specified by the rules in `*utm-2-18*`. It returns `nil` if the tape has run for `n` steps without terminating, or if the tape has encountered a `HALT` symbol. On a Rogozhin UTM, this is equivalent to the head moving past the leftmost symbol written on the tape, `'c<1`. However, for now, we choose to model this with the `HALT` symbol. 

## MTG 

In compliment to our work on UTM(2,18), we've been developing a model of the Turing machine described by *Magic: The Gathering is Turing Complete*[^1] in ACL2. While implementing this Turing machine inside all of the rules of MTG requires several game turns of setup and card-modification (Via card-modifying cards such as [Glamerdye](https://scryfall.com/card/eve/21/glamerdye)), we chose to omit the details of this setup, focusing instead on the resulting structure.

As MTG does not have an ordered list structure anywhere, representing order is tricky. Per *Magic: The Gathering is Turing Complete*[^2], we've implemented the *Creature* card type for this purpose. The *name* of a creature represents one of the 18 symbols in the UTM alphabet- creatures have been chosen such that their names start with different letters, for legibility. The *power and toughness* of a creature determine how far offset it is from the head of the Turing machine, with 2 being the position of the head. The *color* of a creature determines whether the symbol is offset to the left or the right of the head- the creatures representing the tape are either *green* or *white*, representing symbols to the left and right of the head respectively.

Now that we have symbols, we need to model the production functions of UTM(2,18). We model the cards [Rotlung Reanimator](https://scryfall.com/card/ons/164/rotlung-reanimator) and [Xathrid Necromancer](https://scryfall.com/card/c20/141/xathrid-necromancer), which each create a 2/2 black Zombie token, either tapped or untapped, when a certain creature dies. After using some card-modifying game abilities to tweak both the trigger creature and spawned creature, Rotlung and Xathrid become suitable representations of UTM *production functions*. These cards now have the property that they produce new creatures (tape symbols) whenever a certain creature dies (has its *toughness* reduced to 0). While a Rotlung represents a production function where the state remains the same, a Xathrid represents a production function where the state changes. Additionally, four *spell* cards are used, which we model as functions operating on the machine. [Infest]() allows for the removal of the head of the tape, as it reduces all creatures' power and toughness by 2 until the end of the in game turn, which will reduce the head's toughness to 0, killing it (removing the current symbol there) and triggering a Rotlung Reanimator or Xathrid Necromancer to produce a new creature (the new head). [Cleansing Beam](https://scryfall.com/card/cma/78/cleansing-beam) combined with [Vigor](https://scryfall.com/card/bbd/215/vigor) gives all creatures of a certain color 2 additional power and toughness, while [Soul Snuffers](https://scryfall.com/card/td2/60/soul-snuffers) removes 1 power and toughness from all creatures. This allows the tape to move left/right, as we **increase** the offset from the head in one direction, and **decrease** the offset in the other. If, after Cleansing Beam, the tape does not change, the machine has halted. Otherwise, the combination of Cleansing Beam and Soul Snuffers establishes a new head, as some other creature which had 3 power and toughness in either direction will now have 2 power and toughness, which we code as the head. All of these cards are modeled through functions which operate on the "tape", or list of creature tokens which represent symbols on a Turing machine, so that we can produce a new tape and have a function `mtgi` which updates our playing board accordingly.

## Unimplemented MTG

We made a conscious decision **not** to implement certain other parts of MTG (turn-taking, phase/tap state, etc) which the proof uses into ACL2 at the current time. Our reasoning for this is twofold: first, this allows us to build up our model, rather than starting with a more abstract model of MTG and needing to reduce it down to a UTM. This means we can be sure a given reduction works, before implementing more MTG features into our code. Second, we need to be sure that we are able to deliver a product. Implementing the full system for MTG might be outside the scope, so we want to ensure we can deliver a final product by targeting this reduced version of MTG ***first***, and building up from there if we can successfully prove that.

# Current concerns, TODO

Our next steps are as follows:
- Reduce the MTG machine to a simpler machine, which eliminates ordering by toughness/color and orders based on that
- Prove theorems A and B for the two machines
- If time permits, implement tapped creatures and phasing into the MTG model
- reduce this model to our initial MTG model

These first two steps are pivotal to completing our project, and we have begun work on the first one, but don't have any code which is truly deliverable at this time, as we're still working out the logistics of this proof. This step only requires mapping the unordered list of creatures to an ordered list of creatures, with all information about their position removed. We first write a function which processes a list and orderes the creatures accordingly. We then develop a proof that the output of a machine which processes these creatures is equivalent to mapping the first pass of `mtgi` to output on the same tape/program. The second proof we believe is easier than the existing Moore proof, as that proof needed to find an existing natural that caused both programs to terminate with the same tapes, as the M1 machine ran much slower than the Rogers TM, while the UTM/MTG machine are 1-to-1 in terms of steps: the UTM is directly embedded in MTG. Therefore, we do not need to develop the clock lemmas, or find-j/find-k functions which Moore does. We only need to prove theorems A and B, which require some intermediate lemmas, in particular that the MTG machine stays halted when further instructions are run.

The next two steps we began work on, but decided to set aside to focus on getting results from the proof first. These steps would require modelling the tapped state for creatures, as well as *phasing* for the production functions, which is how MTG handles state changes (only one set of production functions is active at one time). This would require adding a boolean to the representation of creatures and production functions, and slowing down the speed at which the MTG TM operates to accurately reflect turns in MTG. This would require developing the clocks similar to what Moore did, although this too would be simpler-- we know that any instruction with a state change takes 3 turns, while any instruction without takes 4 turns. We will attempt to implement this following the success of the initial proof. If we aren't able to implement this step, we still have a working proof of a reduced representation for Magic: The Gathering.

# Overall status


[^1]: https://arxiv.org/pdf/1904.09828.pdf